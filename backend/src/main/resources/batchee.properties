# create new threads via an @Asynchronous method of an EJB
# this also works fine in EE6 and you get all the ThreadLocals for CDI
# and EJB perfectly set up.
# The downside is that you don't have control over the thread size or any other features of ThreadExecutor
BatchThreadPoolService=org.apache.batchee.tools.services.thread.AsyncEjbBatchThreadPoolService

# Switch to handling transactions via a UserTransaction.
# This Service requires the AsyncEjbBatchThreadPoolService to be used!
# This is a workaround for a few containers (like WAS) which don't provide
# a working TransactionManager or UserTransaction in the specified JNDI locations.
TransactionManagementService=org.apache.batchee.tools.services.thread.UserTransactionTransactionService

# Use JPA to store information for the batches
# Check the BatchEE batchee-jbatch-{version}-dbscripts.zip artifact for the
# CREATE TABLE statements for various databases.
# In this sample I just copied it to our testdata.sql script which gets
# created during the build via sql-maven-plugin.
PersistenceManagerService=org.apache.batchee.container.services.persistence.JPAPersistenceManagerService

# We use a container managed EntityManager which gets created via @PersistenceUnit(unitName = "batchee")
# Also see the persistence.xml unitName=batchee and the 'BATCHEE' DataSource definition in tomee.xml.
# Attention: the BATCHEE DataSource must be defined as ResourceLocal and Non-JTA!
persistence.jpa.entity-manager-provider=org.apache.batchee.tools.services.persistence.ContainerManagedEntityManagerProvider
